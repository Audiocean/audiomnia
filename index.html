<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="./css/ol.css">
    <style>
      .map { height: 100%; width: 100%; position: fixed; }
      a { color: #517066; font-weight: bold; }

      body, html { margin: 0; padding: 0; }
      .ol-zoom { left: unset; right: 8px; top: 44px; }

      #results {
        opacity: 0;
        position: absolute;
        top: 76px;
        left: 11vw;
        background: white;
        max-width: 39vw;
        width: 312px;
        max-height: 70vh;
        overflow-y: scroll;
        line-height: 12px;
        min-width: 256px;
        box-shadow: 2px 2px 9px #7d7c7c;
      }

      #results > dd > audio {
        width: 100%;
      }

      /* Stripe the definition list terms and descriptions */
      #results dt:nth-child(4n - 1),
      #results dd:nth-child(4n) {
        background-color: #eaeae9;
      }

      #results dt {
        min-height: 75px; /* Same height as square thumbnail */
      }

      #results dd {
        margin-left: unset;
      }

      cite {
        display: block;
        padding: 2px 2px 4px 2px;
        font-size: 10px;
        text-align: right;
      }
    </style>

    <script src="./js/ol.js"></script>
    <script src="./js/querystring.min.js"></script>

    <title>Global Bioacoustics Map :: Audiomnia</title>
  </head>
  <body>
    <div id="map" class="map"></div>
    <dl id="results"></dl>

    <!-- TODO: Replace with attribution -->
    <!-- <footer style="margin-top: 1em">
      Source code available on <a href="https://github.com/hackforthesea/audiomnia">GitHub</a>.
    </footer> -->

    <script type="text/javascript">
      const MAX_ZOOM = 13;

      var qs = querystring.parse();
      if(qs.hasOwnProperty('birds') && qs.hasOwnProperty('marine')) {
        window.location = "?birds"
      }

      var mapDiv = document.getElementById('map');

      async function renderResults(feature) {
        const props = feature.getProperties()

        const name = props.description[1]
        const sciName = props.description[2]

        const res = await fetch(`https://api.inaturalist.org/v1/taxa?q=${sciName}`)
        const results = (await res.json()).results[0]
        const image = results.default_photo ? results.default_photo.square_url : './img/default_bird.png';

        const date = new Date(props.dateCreated).toDateString()

        const img_tag = new Image()
        img_tag.onload = function() {
          let template = `<dt>`
          template += `     <img style="max-width: 75px; float: left; margin: 4px" src="${image}" alt="" />`
          template += `     <small style="font-size: 10px">${sciName}</small>`
          template += `     <h5 style="margin: 4px 0">${name}</h5>`
          template += `     <time style="font-size: 10px">${date}</time>`
          // Keeping this here in case the contentLocation is needed hidden in the semantics
          // template += `     <div style="font-size: 10px">${props.contentLocation}</div>`
          template += `   </dt>`
          template += `   <dd>`
          template += `     <audio controls><source src="${props.audio}"></audio>`
          template += `     <cite>`
          template += `       ${props.creator}`
          template += `       / Macaulay Library at the Cornell Lab`
          template += `       (<a href="${props.url}">ML529861</a>)`
          template += `     </cite>`
          template += `   </dd>`

          document.querySelector('#results').innerHTML += template
        }
        img_tag.src = image
      }

      const { View, Map, Overlay } = ol
      const { Tile, Vector } = ol.layer;
      const { Stamen, Cluster } = ol.source;
      const { GeoJSON } = ol.format;
      const { Style, Circle, Stroke, Fill, Text } = ol.style;
      const { FullScreen } = ol.control

      function renderMap() {
        let view = new View({
          center: [0, 0],
          zoom: 1,
          maxZoom: MAX_ZOOM
        })

        let attribution

        window.map = new Map({
          controls: ol.control.defaults().extend([new FullScreen()]),
          layers: [
            new Tile({ preload: Infinity, source: new Stamen({ layer: 'terrain' }) }),
            new Tile({ preload: Infinity, source: new Stamen({ layer: 'terrain-labels' }) }),
            // new ol.layer.Tile({
            //   source: new ol.source.TileWMS({
            //     url: 'https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/mapserv',
            //     params: {'LAYERS': 'GEBCO_LATEST', 'TILED': true},
            //     serverType: 'geoserver',
            //     // Countries have transparency, so do not fade tiles:
            //     transition: 0
            //   })
            // }),
            new Vector({
              style: function (cluster) {
                let style
                let features = cluster.get('features') || []
                const zoomLevel = map.getView().getZoom()
                const isMaxZoom = zoomLevel === MAX_ZOOM

                const locationText = isMaxZoom ? new Text({
                  offsetX: 16,
                  textAlign: 'left',
                  font: '12px sans-serif',
                  fontWeight: 'bold',
                  text: `${features[0].getProperties().contentLocation}`,
                  fill: new Fill({ color: '#000' }),
                  stroke: new Stroke({ width: 5, color: '#fff' }),
                }) : null

                // If it is a single feature, then show the pinkish circle for now.
                // TODO: Migrate to images once we figure out the async style situation.
                style = new Style({
                  image: new Circle({
                    radius: 17,
                    stroke: new Stroke({ width: 2, color: '#fff' }),
                    fill: new Fill({ color: '#77CCC7' }),
                  }),
                  text: isMaxZoom ? locationText : new Text({
                    offsetY: 1,
                    textAlign: 'center',
                    font: '10px sans-serif',
                    text: `${features.length}`,
                    fill: new Fill({ color: '#000' }),
                  })
                })

                return style
              },
              source: new Cluster({
                distance: 83,
                source: new ol.source.Vector({
                  format: new GeoJSON({ featureProjection:"EPSG:3857" }),
                  url: "./data/macaulaylibrary.geojson"
                })
              })
            })
          ],
          target: document.getElementById('map'),
          view: view
        });

        map.on('moveend', (event) => {
          const results = document.getElementById('results')
          var map = event.map
          if(map.getView().getZoom() < MAX_ZOOM) {
            results.style.opacity = 0
            results.innerHTML = ''
          }
        })

        map.addEventListener("click", function(e) {
          // Get all the features at the pixl of the mouse click.
          const features = this.getFeaturesAtPixel(e.pixel)
            .filter(f => !(f.type === "VECTOR"))
          if (features.length === 0) return

          // Start with an empty extent, and then loop through the features to grow
          // the extent so that it contains the extent of all the sub-features in
          // the cluster.
          const extent = new ol.extent.createEmpty();
          features[0].get('features').forEach(function(f, index, array){
            ol.extent.extend(extent, f.getGeometry().getExtent());
          });

          // If the extent is minimal, meaning its top left is its bottom right, then
          // render the UI below. TODO: Slow and rude at anything > 30 results. Don't be rude.
          if(extent[0] === extent[2] || extent[1] === extent[3]) {
            // Render the cards below the map
            // Promise.all(features[0].get('features').map(renderResults));
            const goldenSmaller = window.innerWidth / 1.61803844258
            const bottomOffset = window.innerHeight - 40
            view.fit(extent, { duration: 500, padding: [40, goldenSmaller, bottomOffset, 0] });

            // FIXME: For now only grab the first 10 features of any given cluster.
            // FIXME: Either make all of these resolve OR switch to another Promise.all type
            //        mechanism that handles rejections and continues
            document.getElementById('results').innerHTML = ''

            if(features[0].get('features').length > 10) {
              document.getElementById('results').innerHTML =
                '<div style="font-size: 12px; text-align: center; padding: 4px; background: lightyellow">Note: only the first 10 results shown</div>';
            }
            Promise.all(features[0].get('features').slice(0,10).map(renderResults)).then(() => {
              document.getElementById('results').style.opacity = 1
            })
          } else {
            // If there is an extent, "zoom" aka fit the view to the extent,
            // and re-render the map features at the new zoom level.
            const bottomOffset = window.innerHeight / 4
            view.fit(extent, { duration: 500, padding: [80, 60, bottomOffset, 60] });
          }
        })
      }

      renderMap();
    </script>
  </body>
</html>
